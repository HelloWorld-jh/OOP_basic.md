객체지향언어

특징

- 코드의 재사용성이 높다
- 유지보수가 용이
- 중복코드 제거



핵심개념 : 캡슐화, 상속, 추상화, 다형성



<클래스와 객체>

클래스

- 객체의 기능과 특성을 이용하기 위해 정의해놓은 설계도
- 데이터 + 함수 : 서로 관련된 여러 데이터를 하나로 저장할 수 있는 공간
- 사용자 정의 타입: 사용자가 원하는 타입을 직접 만들 수 있음

객체

- 실제로 존재하는 것, 용도는 기능과 속성에 따라 다름
- 클래스(설계도) -> 인스턴스화: 인스턴스(제품)

객체생성: 클래스명 참조변수명 = new 클래스명();

객체배열(참조변수의 배열): 타입[] 배열이름 = new 타입[ n];

**객체 배열 생성 후 반드시 객체를 생성해줄 것**



<변수의 종류>

선언위치에 따른 변수의 종류

클래스 영역

- 클래스변수: 객체생성필요x, 아무때나 사용, 자동생성, 클래스가 메모리에 올라갈 때 생성됨
- 인스턴스 변수: 객체를 생성해야 사용,  객체생성필요, 인스턴스가 생성될 때 사용됨

메서드 영역

- 지역변수: 클래스 이외의 영역(메서드, 생성자, 초기화블럭내부)에서 선언되며 메서드 종료시 자동제거됨

변수선언문이 수행됐을 때 생성됨



<클래스변수와 인스턴스변수>

객체의 속성: 숫자, 무늬...독립적 속성 (인스턴스 변수) 참조변수. 변수이름 ex) c.kind = "heart";

​						폭, 높이 ... 공통적 속성(클래스 변수) 클래스이름. 변수이름

**인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 각기 다른값으로 유지할 수 있지만,

클래스 변수는 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다 **



<지역변수>

- 메서드 내에 선언된 변수. 메서드 영역이 서로 다른 지역변수들은 이름이 중복되어도 관계없다.

<메서드> 

꼭 클래스 안에 있어야 함

- 문장들을 작업단위로 묶어서 이름붙인것
- 값(입력)을 받아서 처리하고, 결과를 반환(출력)
- 장점
  - 코드중복을 줄일 수 있음
  - 한 곳에서 수행하기 때문에 관리가 쉽다.
  - 코드 재사용 가능
  - 코드가 간결해서 흐름을 이해하기 쉬움

- 메서드 작성: 반복되는 여러 문장을 메서드로 작성.

  ​						하나의 메서드는 한가지 기능만 수행하도록 작성

- 메서드 = 선언부 + 구현부

선언부 반환타입 메서드명 (타입 변수명, 타입 변수명){

구현부 // 메서드 호출 시 실행 될 코드

}

- 메서드 호출: 메서드 이름(값1, 값2,....);

- 메서드 실행흐름

  - 1 객체 생성 -> 2 메서드 호출 -> 메서드 안 수행문 실행 -> 호출한 곳으로 반환

- return문

  - 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아 간다
  - 반환타입이 void가 아닌 경우, 반드시 return문 필요
  - 조건식 쓸 떄(메서드 내에서) return문이 거짓일 경우에도 쓰여있는지 확인할 것

- 반환값: 반환 타입이 void가 아닌 경우, 반환 타입을 일치시켜야 됨, 또는

  ​				자동 형 변환이 가능한 타입 (int인 경우 byte, short, char)

- 매개변수의 유효성 검사

  - 적절하지 않은 값이 들어오면 매개변수의 값을 보정하던가,

    return문으로 작업을 중단하고 호출한 메서드로 되돌아가게 하는 코드를 반드시 넣어야 한다.

- 기본형 매개변수와 참조형 매개변ㅅ후

  - 기본형(8개) 매개변수: 변수의 값을 읽기만 가능 READ ONLY
  - 참조형 매개변수: 변수의 값을 읽고 변경할 수 있음 READ & WRITE

- 호출스택

  - 메서드 수행에 필요한 메모리가 제공되는 공간
  - 메서드가 호출되면 호출스택에 메모리가 할당, 종료되면 해제
  - 맨위의 메서드만 실행중, 나머지는 대기

- 참조형 반환 타입:  Static Data copy(Data d) {}

  - 객체주소(0x100)를 반환한다
  - 객체주소를 줬기 때문에 객체를 다룰 수 있게 됨

- 재귀호출: 메서드가 자기자신을 호출해서 스스로 수행시키는 것



<클래스 메서드와 인스턴스 메서드>

- 인스턴스 메서드 (객체 필요)

  - 인스턴스 생성 후 "참조변수.메서드이름()"으로 호출
  - 인스턴스 멤버와 관련된 작업을 하는 메서드
  - 메서드에서 인스턴스 변수 사용가능

- static 메서드

  - 객체 생성없이 "클래스이름.메서드이름()"으로 호출

  - 인스턴스 멤버와 관련없는 작업을 하는 메서드

  - 메서드 내에서 인스턴스 변수 사용불가(사용하지 않으면 static 붙여라)

  - 메서드간 호출과 참조

    - static 메서드 호출x-> 인스턴스 메서드

      ​						<-호출o

      인스턴스 메서드가 호출 됐으면 이미 객체 생성

      static메서드는 사용불가( 객체가 있는지 없는지 모르니까)



<오버로딩>

- 한 클래스 안에 같은 이름의 메서드를 여러개 정의하는 것
- 성립조건
  - 메서드 이름이 같아야함
  - 매개변수의 개수 or 타입이 달라야 한다
  - 반환타입은 영향없음
- 올바른 예 : 매개변수는 다르지만 같은 의미의 기능 수행 ex) println();

<생성자>

- 인스턴스가 생성될 때마다 호출되는 "인스턴스 초기화 메서드"
- 규칙 
  - 생성자 이름이 클래스 이름과 같아야 함
  - 리턴값이 없다(void 안 붙임)
  - 모든 클래스는 반드시 생성자를 가진다

<기본 생성자>

- 클래스 이름() {}.. (매개변수) 도 {하는 일}도 없음
- 매개변수가 없는 생성자
- 생성자가 하나도 없을 때만 컴파일러가 자동추가 해줌

<매개변수가 있는 생성자>

- 인스턴스를 생성하는 동시에 원하는 값으로 초기화 할수 있게됨
- 인스턴스 생성 후 인스턴스 변수의 값을 변경하는 것보다 더 코드가 간결함

<생성자 this()>

- 규칙

  - 생성자에서 같은 클래스의 다른 생성자를 호출할 때,

    클래스 이름 대신 this를 사용함

  - 다른 생성자 호출 시 첫 줄에서만 사용가능

    (다른 생성자로 인해 호출 이전의 초기화 작업이 무의미해지므로 첫줄!)



<참조변수 this>

- 인스턴스 변수와 지역변수의 이름이 같을 때 구별하려고 사용

  this가 붙으면 인스턴스 변수, 안 붙으면 매개변수와 가까운 지역변수가 됨

- 인스턴스 자신을 가르키는 참조변수 (객체주소가 저장되어 있음)

- 인스턴스 메서드에서 사용 / static 메서드에서는 사용불가



<변수의 초기화>

- 멤버변수(인스턴스 변수, 클래스 변수)는 자동 초기화

- 지역변수는 수동으로 초기화

- 멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만,

  지역변수의 초기화는 필수적이다

- 멤버변수 초기화 방법

  - 명시적 초기화
  - 생성자
  - 초기화 블럭
    - 인스턴스 초기화 블럭:  인스턴스 변수를 초기화 하는데 사용
    - 클래스 초기화 블럭:  클래스 변수를 초기화 하는데 사용



<멤버변수의 초기화와 시기, 순서>

- 클래스 변수의 초기화 시점
  - 클래스가 처음 로딩될 때 단 한 번 초기화
- 인스턴스 변수의 초기화 시점
  - 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다
- 클래스 변수의 초기화 순서
  - 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수의 초기화 순서
  - 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자



<상속>

- 기존 클래스로 새로운 클래스를 작성하는 것(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것
- 자손은 조상의 모든 멤버를 상속받는다 (생성자, 초기화블럭 제외)
- 자손의 변경은 조상에 영향을 미치지 않는다
- 자손의 멤버개수는 조상보다 적을 수 없다(같거나 많다)



<포함관계>

- 클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 것

- 작은 단위의 클래스를 만들고 이들을 조합해서 클래스를 만든다

- 클래스간 관계 결정하기

  - 상속관계: ~는 ~이다 (~is a ~.)

     					extends Point{

  - 포함관계: ~는 ~를 가지고 있다 (~has a ~.)

    ​					Point c = new Point(); // 대부분(90%)  잘 모를 땐 포함

<단일 상속>

- Java는 단일상속(하나의 부모만 상속)만 허용
- 비중이 높은 클래스만 상속, 나머지는 포함관계로 한다



Object 클래스

- 모든 클래스의 조상, 부모가 없는 클래스는 자동으로 Object 클래스를 상속받음
- 모든 클래스는 Object  클래스에 정의된 11개의 메서드를 상속받는다



<메서드 오버라이딩>

- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것
- 조건
  - 선언부가 조상과 일치
  - 접근제어자를 조상클래스보다 좁은 범위로 변경할 수 없음
  - 예외는 조상메서드 보다 많이 선언할 수 없음

오버로딩(new) vs 오버라이딩(change, modify)

자손에 없는 새로운 메서드를 정의ex. 이름이 같고 매개변수가 다르는 등

vs 상속받은 메서드의 내용을 변경하는 것, 가져다가 씀



<참조변수 super>

- 객체 자신을 가르키는 참조변수. 인스턴스 메서드(생성자) 내에서만 존재
- 조상의 멤버를 자신의 멤버와 구별할 때 사용



<조상의 생성자 super()>

- 조상의 생성자를 호출할 때 사용(생성자와 초기화 블럭은 상속 안 되니까)
- 조상의 멤버는 조상의 생성자를 호출해서 초기화, 자손의 생성자는 자신이 선언한 변수만 초기화 할 수 있다
- 생성자는 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면,

 컴파일러가 생성자의 첫줄에 super()를 삽입... 모든 클래스 조상이 Object기 때문



<패키지>

- 클래스는 클래스파일(*.class), 패키지는 폴더, 하위패키지
- 클래스의 실제이름은 패키지를 포함
- 패키지의 선언: Pachage 패키지명;
- 같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 됨

<클래스패스(환경변수)>

- 클래스파일(*.class) 위치를 알려주는 경로(path)
- 환경변수로 관리하며 경로간 구분은 ';'을 사용



<import문> 

- 클래스를 사용할 때 패키지이름을 생략할 수 있다
- 컴파일러에게 클래스가 속한 패키지를 알려준다
- 선언: import 패키지명.클래스명;
- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 및 패키지명
- static import문
  - static멤버(static메서드, 클래스변수)를 사용할 때, 클래스 이름을 생략하게 해줌



<제어자>

- 클래스와 클래스멤버(멤버변수, 메서드)에 부가적인 의미부여
  - 접근제어자:pulic, default, protected, private
  - 그 외: static, final, abstract
- 하나의 대상에 여러 제어자를 같이 사용가능 (접근제어자는 한개만)
- 접근제어자를 맨 왼쪽으로..
- static ... 클래스의, 공통적인
  - static은 멤버변수, 메서드, 초기화 블럭에서 사용 (객체생성 없이도)
  - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다
- final... 마지막의, 변경될 수 없는
  - 클래스: 변경, 확장불가능한 클래스, 상속계층도의 제일 마지막. 자손없는 클래스
  - 변수(인스턴스 변수, 지역변수): 상수
  - 메서드: 오버라이딩이 불가능한 메서드 (변경될 수 없는)
- abstract... 추상의, 미완성의
  - 클래스: 클래스 안에 추상메서드가 있음 (미완성 설계도)
  - 메서드: 선언부만 있고 구현부가 없는 메서드
  - abstract 클래스는 객체를 생성할 수 없고, 추상메서드를 갖고 있으니 상속받아서 완성해줘야 하는구나 알아야 함
- 캡슐화와 접근제어자
  - 왜 접근제어자를 사용해야 하는가?
    - 외부로부터 데이터를 보호하기 위해 (외부에서 메서드를 통해 간접접근 허용)
    - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해



<다형성>

- 장점: 조상타입 참조변수로 자손타입 객체를 다루는 것 (자손타입으로 조상객체는 다룰 수 없음)

  ​			하나의 배열에 여러 종류의 객체 저장

- 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버개수보다 같거나 적어야 한다

- 참조변수 타입과 인스턴스 타입은 보통 일치하지만 일치하지 않을 수도 있다



<참조변수의 형변환>

- (리모컨을 변경함으로써) 사용할 수 있는 멤버의 갯수를 조절하는 것

- 조상, 자손관계의 참조변수는 서로 형변환이 가능(형제 관계는 없다)

- 리모컨 기능이 많은 쪽에서 적은 쪽으로 줄이는 건 안전. 자손 -> 조상 o

  적은 쪽을 늘릴 때는 안전하지 않으니 형변환 꼭 하자. 조상 -> 자손



<instanceof 연산자>

- 참조변수의 형 변환 가능여부 확인용. 가능하면 true 반환
- 형변환 전에 반드시 instanceof로 확인해야 함
- 주로 조건문에 사용 if(참조변수 instanceof 타입(클래스명))



<매개변수의 다형성>

- 참조형 매개변수는 메서드 호출시 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다

<여러종류의 객체를 배열로 다루기>

- 조상타입의 배열에 자손타입 객체를 담을 수 있다

- 다루고 싶은 객체들의 상속관계를 따져서 

  가장 가까운 공통조상 클래스타입의 참조변수 배열을 생성해서 객체들을 저장



<추상클래스>

- 미완성 설계도. 미완성 메서드를 갖고 있는 클래스
- 다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성불가
- 상속을 통해 추상메서드를 완성해야 인스턴스 생성가능
  - 추상클래스를 상속받아
  - 추상메서드의 {구현부} 완성
  - 완성된 설계도 (객체생성)



<추상메서드> abstract 리턴타입 메서드이름();

- 미오나성메서드. 구현부{몸통}이 없는 메서드

- 공통적으로 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우

  (몸통이 자손마다 다를경우)

- 추상메서드를 한개라도 구현하지 않으면 여전히 미완성

- 필수적인 기능이라서 강제성 有

- 여러 클래스에 공통적으로 쓸 수 있는 추상클래스를 바로 작성하거나

  기존클래스의 공통된 부분을 뽑아서 추상클래스를 작성



<추상클래스의 작성>

- 장점: 1. 설계도를 쉽게 작성 2. 코드 중복 제거 3. 코드관리가 용이
- 구체화 된 코드보다 유연 (변경에 유리)
- ㅜ상화: 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업



<인터페이스>

- 추상메서드의 집합
- 구현된 것이 전혀 없는 설계도, 껍데기 (모든 멤버가 public)
- 추상메서드 vs 인터페이스

추상메서드: 추상메서드를 가진 일반클래스

인터페이스: 추상메서드 빼고 구현된 것이 아무것도 없음

- 인터페이스 선언

interface 인터페이스 이름 {

​				public static final 타입 상수이름 = 값; //상수

​				public abstract 메서드이름(매개변수목록); // 추상메서드

}



- 인터페이스의 조상은 인터페이스만 가능 (Object가 최고조상 아님)
- 다중상속이 가능 (추상메서드는 충돌해도 문제x)
- public, static, final, abstract 전부 생략가능
- 인터페이스의 구현 ( 인터페이스에 정의된 추상메서드를 완성하는 것)

class 클래스이름 implements 인터페이스 이름 {

​		(인터페이스에 저으이된 추상메서드를 모두 구현해야함)

}

- 일부만 구현하는 경우, 클래스 앞에 abstract를 붙여야 함

- 추상클래스와는 둘 다 추상메서드를 가진다는 공통점이 있지만,

  인터페이스는 인스턴스 변수를 가질 수 없다.



<인터페이스를 이용한 다형성>

- 인터페이스도 구현클래스의 부모이다
- 인터페이스 타입의 매개변수는 인터페이스를 구현한 클래스의 객체만 가능
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다 -> 안 맞으면 형변환

(이 인터페이스를 구현한 놈을 반환하겠다는 뜻)

![image-20210916232828870](C:\Users\wngud\AppData\Roaming\Typora\typora-user-images\image-20210916232828870.png)



<인터페이스의 장점>

- 두 대상(객체)간의 '연결, 대화, 소통'을 돕는 '중간역할'을 한다

![image-20210916232911749](C:\Users\wngud\AppData\Roaming\Typora\typora-user-images\image-20210916232911749.png![image-20210916233019926](C:\Users\wngud\AppData\Roaming\Typora\typora-user-images\image-20210916233019926.png)

- 변경에 유리한 설계 가능
- 선언과 구현을 분리할 수 있다

![image-20210916233051591](C:\Users\wngud\AppData\Roaming\Typora\typora-user-images\image-20210916233051591.png)

- 개발시간을 단축할 수 있다.

![image-20210916233115141](C:\Users\wngud\AppData\Roaming\Typora\typora-user-images\image-20210916233115141.png)

- 표준화가 가능하다 ex. JDBC(인터페이스 집합)
- 서로 관계없는 클래스들을 관계 맺어줄 수 있다.
